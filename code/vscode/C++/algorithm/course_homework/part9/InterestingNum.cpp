#include <iostream>
using namespace std;
unsigned long long B, k, m, kk, cnt = 0;
int main()
{
    cin >> k >> m;
    for (B = 1; B <= k; B *= 10) // cnt最后是：在k前面且比k小的数的个数
    {
        cnt += k / B - B + 1;
    }
    cnt--;
    B /= 10;                                  //例如k=456，B=100
    if (cnt >= m || (cnt != m - 1 && B == k)) // m至少要等于cnt+1 且 如果B=k，m一定等于cnt+1
        cout << 0 << endl;
    else if (m == cnt + 1)
        cout << k << endl;
    else
    {
        for (B = k - B, kk = k; cnt < m - 1;) //再分区间计算大于k且在k前面的数的个数
        {
            kk = kk * 10;
            B = B * 10;
            cnt += B;
        }
        cout << kk - cnt + m - 2 << endl; //前者是转换了的公式
    }
}
/*
数学老师数学兔给出了一个数字N，表示1-N的所有数字，但是他们的排列顺序不是按照一般的大小排列的，而是按照字典序排列的

比如N=11时，为1,10,11,2,3,4,5,6,7,8,9

然后给出了一个M，表示第M个数字，即S(N,M) = K

S(11,4) = 2，表示N=11时的字典序数列的第4个数为2

那么，问题来了：给定K和M，求一个最小的N使得S(N,M) = K
*/

/*
用cnt表示在k前面的元素个数。
k=456，m=1000为例

先找出比456小且在它前面的元素个数：[100,456] [10,45] [1,4],其中456不能计入，要减1。
个数和为：(456/1-100+1-1)+(456/10-10+1)+(456/100-1+1)=(456/1-1+1)+(456/10-10+1)+(456/100-100+1)-1  说明这是一个有规律的式子，可以令B=1，逐步乘以10去算
这时cnt=396

再判断m合理性：m至少要等于cnt+1 且 如果k=B(此处为100)，m一定等于cnt+1(可以自己算算去体会一下)，不满足就输出0

如果m=cnt+1，输出k即可

再找出比456大且在它前面的元素个数：[1000,4559] [10000,45599]等等，使得cnt逐步逼近m。
令B为当前区间的元素个数，kk为当前区间的最大值+1(先不管它，在后面有用)，cnt+=B进行计数。
当考虑[1000,4559]区间时，cnt>1000-1，说明个数已经超过，进一步说明N应该在[1000,4559]区间里面，使得一直加到N的时候刚好有m-1个数，那么下一个就是456。
此时cnt=4559-1000+1+396，kk=4560

这时就需要一波详尽的计算得到N的值。
用&&&表示小于1000且在456前面的元素个数。(因为确定了N在[1000,4559]区间)
很容易得到式子：m-1=(N-1000+1)+&&&
代入值再变换一下就是：N=1000-&&&+m-2
又因为当前算出来的cnt：cnt=(4559-1000+1)+&&&=(4560-1000)+&&&=kk-1000+&&&
所以有：kk-cnt=1000-&&&  代入N的式子
得到：N=kk-cnt+m-2
*/