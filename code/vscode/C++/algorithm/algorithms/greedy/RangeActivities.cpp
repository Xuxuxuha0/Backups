#include <iostream>
#include <algorithm>
using namespace std;
bool cmp(int a, int b)
{
    return a < b;
}
int main()
{
    int ans = 0, n, i, j;
    cin >> n;
    int *a = new int[n];
    int *b = new int[n];
    for (i = 0; i < n; i++)
        scanf("%d%d", &a[i], &b[i]); //用c语言输入快得多
    sort(a, a + n);
    sort(b, b + n);
    i = 0;
    j = 0;
    while (i < n)
    {
        if (a[i] < b[j])
            ans++;
        else
            j++;
        i++;
    }
    cout << ans << endl;
}
/*
假设要用很多个教室对一组活动进行调度。我们希望使用尽可能少的教室来调度所有的活动。
第一行为活动的个数 N(1<=N<=1 000 000)。
接下来 N 行为 Si 和 Fi(0<=Si<Fi<=2 000 000 000) ，分别代表第 i 个活动的开始时间和结束时间。活动 i 的区间段为 [Si,Fi)

算法非常神奇：
总体来讲就是从开始时间由小到大，依次安排事件进行

例如：
开始时间：1 3 0 5 3 5 6  8  8  2  12
结束时间：4 5 6 7 8 9 10 11 12 13 14

1、
    先把开始时间和结束时间分别排序
    开始时间a[]：0 1 2 3 3 5 5  6  8  8  12
    结束时间b[]；4 5 6 7 8 9 10 11 12 13 14
2、
    假设现在有ans个教室。(起初是0)
    设当前考虑的起始时间为a[i],当前考虑的结束时间为b[j]。

    a[0]=0,b[0]=4:无实际意义，只是碰巧“不初始化代入循环里面去”和“初始化”的结果相同。i++，ans++。
    a[1]=1,b[0]=4:表示当前考虑的事件0开始于0，当前正在做的事件的最早结束时间大于等于4；所以ans++，开辟新教室来进行该事件，同时i++，考虑下一个事件。
    a[1]=1,b[0]=4同上...
    ...
    a[5]=5,b[0]=4:表示当前考虑的事件5开始于5，5>4意味着以4为结束时间的事件已经做完，那么事件5就可以接在它后面继续做。同时i++，j++，考虑下一个事件，同时看看有没有事件做完了。
    以此类推。
*/